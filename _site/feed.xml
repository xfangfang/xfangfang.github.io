<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>xfang</title>
        <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
        <link>http://localhost:4000/</link>
        <description>A website with blog posts and pages</description>
        <pubDate>Sat, 17 Mar 2018 14:23:59 +0800</pubDate>
        
        <item>
            <title>对 XAML UI 的评价</title>
            <link>/uwp/009</link>
            <guid isPermaLink="true">/uwp/009</guid>
            <description>
</description>
            <pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
        </item>
        
        <item>
            <title>Hello Every One</title>
            <link>/test/008</link>
            <guid isPermaLink="true">/test/008</guid>
            <description>&lt;h1 id=&quot;i-am-a-big-title&quot;&gt;I am a BIG title&lt;/h1&gt;

&lt;p&gt;更换了新的博客&lt;/p&gt;

&lt;p&gt;测试一下都支持什么功能&lt;/p&gt;
</description>
            <pubDate>Fri, 16 Mar 2018 00:00:00 +0800</pubDate>
        </item>
        
        <item>
            <title>【新建项目&amp;使用viewPager】实现一个Android电子书阅读APP</title>
            <link>/android/006</link>
            <guid isPermaLink="true">/android/006</guid>
            <description>&lt;p&gt;小说阅读器最终实现效果见&lt;a href=&quot;http://www.cnblogs.com/xfangs/p/6494645.html&quot;&gt;上一篇博文&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;新建一个项目&quot;&gt;新建一个项目&lt;/h1&gt;

&lt;p&gt;呼～我们即将步入安卓开发之旅了，首先要新建一个项目。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303150203595-480159064.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择了开始新项目之后，会打开一个窗口让你设置应用的名字(大写字母开头)，还要设置一个类似网址的东西，用来区别不同的开发者，如果你有自己的域名可以像我一样直接设置(宣传一波小方自己的站点～&lt;a href=&quot;http://xfangfang.cn&quot;&gt;http://xfangfang.cn&lt;/a&gt;)，或者设置一个自己喜欢的地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303150726907-60725034.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后是对默认界面进行选择，这里我们选择空白的activity 就好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303150835345-805165710.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一路点击NEXT，我们就制作好了一个可以运行的Android程序，我们会看到如下的界面。&lt;/p&gt;

&lt;h1 id=&quot;简单介绍安卓编程&quot;&gt;简单介绍安卓编程&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303151946641-482372948.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左边就是你的阅读应用的项目目录，不同的文件夹里存放着不同的文件，上图已经进行了粗略的描述，如果有什么不清楚的地方，大家还请移步搜索引擎。&lt;/p&gt;

&lt;p&gt;下面来仔细阅读一番MainActivity这个文件的内容。&lt;/p&gt;

&lt;pre&gt;1 public class MainActivity extends AppCompatActivity {
2
3     @Override
4     protected void onCreate(Bundle savedInstanceState) {
5         super.onCreate(savedInstanceState);
6         setContentView(R.layout.activity_main);
7     }
8 }&lt;/pre&gt;

&lt;p&gt;Activity 是安卓的四大组件之一，可以简单理解为我们运行的程序的每一个界面都对应了一个活动(Activity)，所以活动就是我们写代码的主战场，当一个活动开始运行时，就会调用我们重写的函数 &lt;strong&gt;onCreat&lt;/strong&gt; ，在这个函数中 &lt;strong&gt;setContentView(R.layout.activity_main)&lt;/strong&gt; 设置了布局文件，目的是为我们的活动提供一个显示界面。&lt;/p&gt;

&lt;p&gt;布局文件保存在layout文件夹下，以.xml为后缀，下面我们仔细了解一下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303160913141-1006577453.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安卓使用xml文件作为布局文件，一个闭合的括号代表一个组件，有的组件可以作为容器盛放其他的组件，如上图中的 RelativeLayout，就能盛放 TextView，使用这种”容器”的目的是更好的编写安卓的界面，适用不同分辨率，不同屏幕比例的安卓设备。&lt;/p&gt;

&lt;p&gt;除了使用代码编写界面，android studio 还提供了另一种设置布局的方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303163403188-786854534.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个界面下，我们只需要使用鼠标通过简单的拖动就能完成界面设计，不过很遗憾，拖动的方法并不是万能的，程序并不能完全明白人类的想法，使用拖动组件和直接编写xml文件相结合才能更好的完成工作。同样的，在这里不多加赘述安卓开发入门的知识，小方这次的教程博客并不预计在基础部分占用太多篇幅，只是引入相关概念，初学者可以根据不同的关键词自行上网检索。&lt;/p&gt;

&lt;h1 id=&quot;开始运行&quot;&gt;开始运行&lt;/h1&gt;

&lt;p&gt;介绍至此，我们可以尝试运行一下目前的代码，可以使用真机连接数据线至电脑进行调试，也可以使用安卓虚拟机。&lt;/p&gt;

&lt;p&gt;小方使用的是 Genymotion 的虚拟机运行程序，点击上面工具栏中的绿色小箭头，选择好设备就能将程序运行在设备之中了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303165232626-1071110537.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，身为初学者的你可以试着运行一下你所新建的安卓程序了，还可以试着更改TextView的文字。&lt;/p&gt;

&lt;h1 id=&quot;使用viewpager&quot;&gt;使用ViewPager&lt;/h1&gt;

&lt;p&gt;先看一下在成品APP中我们的ViewPager最终的实现效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303171637173-956547479.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;第一步-修改布局&quot;&gt;第一步 修改布局&lt;/h1&gt;

&lt;p&gt;ViewPager这个东西，在小方看来就是将多个活动放在一起，可以便捷的滑来滑去，这样说来，我们就需要多个不同的布局文件，分别对应ViewPager中每一页的内容，右键layout文件夹，点击新建，选择第一项Layout resource file 就能建立一个布局文件，默认的布局文件中包含了LinearLayout，咱们可以随便放里面一个TextView作为对两个界面的不同标记。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303184942595-1595930038.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，新建了两个文件。&lt;/p&gt;

&lt;p&gt;下面开始修改主界面布局，将ViewPager插入到布局之中。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;activity_main.xml&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt; 1 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
 2 &amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
 3     xmlns:tools=&quot;http://schemas.android.com/tools&quot;
 4     android:id=&quot;@+id/activity_main&quot;
 5     android:layout_width=&quot;match_parent&quot;
 6     android:layout_height=&quot;match_parent&quot;
 7     android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
 8     android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
 9     android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
10     android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
11     tools:context=&quot;cn.xfangfang.reader.MainActivity&quot;&amp;gt;
12
13     **&amp;lt;android.support.v4.view.ViewPager
**14**         android:id=&quot;@+id/container&quot;
**15**         android:layout_width=&quot;match_parent&quot;
**16**         android:layout_height=&quot;match_parent&quot;/&amp;gt;**
17
18 &amp;lt;/RelativeLayout&amp;gt;&lt;/pre&gt;

&lt;p&gt;到此为止，布局文件的设置内容已经结束，下面开始对MainActivity进行修改。&lt;/p&gt;

&lt;h1 id=&quot;第二步-创建fragment&quot;&gt;第二步 创建Fragment&lt;/h1&gt;

&lt;p&gt;之前说到，ViewPager 上存在着很多界面，这里每一个界面就是一个Fragment，Fragment可以理解为类似Activity的东西，我们需要为每一个界面建立一个自己的Fragment类继承自Fragment。&lt;/p&gt;

&lt;pre&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 1&lt;/span&gt;     &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt; FindBooksFragment &lt;span style=&quot;color: #0000ff;&quot;&gt;extends&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Fragment {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 2&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt; 3&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; FindBooksFragment() {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 4&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 5&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt; 6&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        @Override
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 7&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; View onCreateView(&lt;span style=&quot;color: #0000ff;&quot;&gt;final&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; LayoutInflater inflater, ViewGroup container,
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 8&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;                                 Bundle savedInstanceState) {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 9&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;10&lt;/span&gt;             View rootView = inflater.inflate(**R.layout.pager_book_find**, container, &lt;span style=&quot;color: #0000ff;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;11&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;12&lt;/span&gt;             &lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; rootView;
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;13&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;14&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;15&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;    }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;16&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;17&lt;/span&gt;     &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt; ReadListFragment &lt;span style=&quot;color: #0000ff;&quot;&gt;extends&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Fragment {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;18&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;19&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ReadListFragment() {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;20&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;21&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;22&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        @Override
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;23&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; View onCreateView(&lt;span style=&quot;color: #0000ff;&quot;&gt;final&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; LayoutInflater inflater, ViewGroup container,
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;24&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;                                 Bundle savedInstanceState) {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;25&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;26&lt;/span&gt;             View rootView = inflater.inflate(**R.layout.pager_book_list**, container, &lt;span style=&quot;color: #0000ff;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;27&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;28&lt;/span&gt;             &lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; rootView;
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;29&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;30&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;31&lt;/span&gt;     }&lt;/pre&gt;

&lt;p&gt;注意上面代码块中加粗的两行，我们需要把自己刚刚新建的两个布局文件的名字分别写到加粗指定的位置，在Fragment被创建的时候，就会自动调用onCreatView函数，这里暂时先不写其他功能。&lt;/p&gt;

&lt;p&gt;创建好了两个Fragment，我们还需要为ViewPager设置一个适配器。&lt;/p&gt;

&lt;h1 id=&quot;第三步-创建viewpager的适配器&quot;&gt;第三步 创建ViewPager的适配器&lt;/h1&gt;

&lt;pre&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 1&lt;/span&gt;     &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt; SectionsPagerAdapter &lt;span style=&quot;color: #0000ff;&quot;&gt;extends&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; FragmentPagerAdapter {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 2&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; ArrayList&amp;lt;Fragment&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt; datas;
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 3&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt; 4&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SectionsPagerAdapter(FragmentManager fm) {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 5&lt;/span&gt;             &lt;span style=&quot;color: #0000ff;&quot;&gt;super&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(fm);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 6&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 7&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt; 8&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; setData(ArrayList&amp;lt;Fragment&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt; datas) {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 9&lt;/span&gt;             &lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;.datas =&lt;span style=&quot;color: #000000;&quot;&gt; datas;
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;10&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;11&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;12&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        @Override
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;13&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; Fragment getItem(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; position) {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;14&lt;/span&gt;             &lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; datas == &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; ? &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; : datas.get(position);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;15&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;16&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;17&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        @Override
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;18&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; getCount() {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;19&lt;/span&gt;             &lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; datas == &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; ? 0&lt;span style=&quot;color: #000000;&quot;&gt; : datas.size();
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;20&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        }
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;21&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;22&lt;/span&gt;     }&lt;/pre&gt;

&lt;p&gt;在这里适配器起到把Fragment传给ViewPager的作用，通过重写getItem函数，我们就将 SectionsPagerAdapter 中的datas传给了ViewPager。&lt;/p&gt;

&lt;h1 id=&quot;最后-整合&quot;&gt;最后 整合&lt;/h1&gt;

&lt;p&gt;下面来看MainActivity的onCreat函数。&lt;/p&gt;

&lt;pre&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 1&lt;/span&gt;     &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SectionsPagerAdapter mSectionsPagerAdapter;
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 2&lt;/span&gt;     &lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ViewPager mViewPager;
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 3&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt; 4&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;    @Override
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 5&lt;/span&gt;     &lt;span style=&quot;color: #0000ff;&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 6&lt;/span&gt;         &lt;span style=&quot;color: #0000ff;&quot;&gt;super&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 7&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        setContentView(R.layout.activity_main);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt; 8&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt; 9&lt;/span&gt;         mSectionsPagerAdapter = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SectionsPagerAdapter(getSupportFragmentManager());
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;10&lt;/span&gt;         ArrayList&amp;lt;Fragment&amp;gt; datas = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;();
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;11&lt;/span&gt;         datas.add(&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ReadListFragment());
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;12&lt;/span&gt;         datas.add(&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; FindBooksFragment());
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;13&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        mSectionsPagerAdapter.setData(datas);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;14&lt;/span&gt;
&lt;span style=&quot;color: #008080;&quot;&gt;15&lt;/span&gt;         mViewPager =&lt;span style=&quot;color: #000000;&quot;&gt; (ViewPager) findViewById(R.id.container);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;16&lt;/span&gt; &lt;span style=&quot;color: #000000;&quot;&gt;        mViewPager.setAdapter(mSectionsPagerAdapter);
&lt;/span&gt;&lt;span style=&quot;color: #008080;&quot;&gt;17&lt;/span&gt;     }&lt;/pre&gt;

&lt;p&gt;在MainActivity中声明ViewPager和它的适配器。&lt;/p&gt;

&lt;p&gt;9-13行 初始化了适配器，并将两个Fragment加入到适配器的datas数组中。&lt;/p&gt;

&lt;p&gt;15行 相信大家都懂，不懂的同学可以搜索学习一番。&lt;/p&gt;

&lt;p&gt;最后为ViewPager设置适配器。&lt;/p&gt;

&lt;p&gt;短短几步我们就完成了一个ViewPager的创建全过程，让我们的程序跑起来～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170303193530016-173347746.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看是不是已经有了咱们阅读应用的雏形了，下面附上MainActivity的全部代码。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;&lt;em&gt;MainActivity&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt; MainActivity &lt;span style=&quot;color: #0000ff;&quot;&gt;extends&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; AppCompatActivity {

    &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SectionsPagerAdapter mSectionsPagerAdapter;
    &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ViewPager mViewPager;

    @Override
    &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;super&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mSectionsPagerAdapter &lt;/span&gt;= &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SectionsPagerAdapter(getSupportFragmentManager());
        ArrayList&lt;/span&gt;&amp;lt;Fragment&amp;gt; datas = &lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt;();
        datas.add(&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ReadListFragment());
        datas.add(&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;new&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; FindBooksFragment());
        mSectionsPagerAdapter.setData(datas);

        mViewPager &lt;/span&gt;=&lt;span style=&quot;color: #000000;&quot;&gt; (ViewPager) findViewById(R.id.container);
        mViewPager.setAdapter(mSectionsPagerAdapter);
    }

    &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt; FindBooksFragment &lt;span style=&quot;color: #0000ff;&quot;&gt;extends&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Fragment {

        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; FindBooksFragment() {
        }

        @Override
        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; View onCreateView(&lt;span style=&quot;color: #0000ff;&quot;&gt;final&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; LayoutInflater inflater, ViewGroup container,
                                 Bundle savedInstanceState) {

            View rootView &lt;/span&gt;= inflater.inflate(R.layout.pager_book_find, container, &lt;span style=&quot;color: #0000ff;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;);

            &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; rootView;
        }

    }

    &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;static&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt; ReadListFragment &lt;span style=&quot;color: #0000ff;&quot;&gt;extends&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Fragment {

        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ReadListFragment() {
        }

        @Override
        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; View onCreateView(&lt;span style=&quot;color: #0000ff;&quot;&gt;final&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; LayoutInflater inflater, ViewGroup container,
                                 Bundle savedInstanceState) {

            View rootView &lt;/span&gt;= inflater.inflate(R.layout.pager_book_list, container, &lt;span style=&quot;color: #0000ff;&quot;&gt;false&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;);

            &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; rootView;
        }

    }

    &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;class&lt;/span&gt; SectionsPagerAdapter &lt;span style=&quot;color: #0000ff;&quot;&gt;extends&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; FragmentPagerAdapter {
        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt; ArrayList&amp;lt;Fragment&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt; datas;

        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; SectionsPagerAdapter(FragmentManager fm) {
            &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;super&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;(fm);
        }

        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; setData(ArrayList&amp;lt;Fragment&amp;gt;&lt;span style=&quot;color: #000000;&quot;&gt; datas) {
            &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;this&lt;/span&gt;.datas =&lt;span style=&quot;color: #000000;&quot;&gt; datas;
        }

        @Override
        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; Fragment getItem(&lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; position) {
            &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; datas == &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; ? &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; : datas.get(position);
        }

        @Override
        &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;int&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; getCount() {
            &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;return&lt;/span&gt; datas == &lt;span style=&quot;color: #0000ff;&quot;&gt;null&lt;/span&gt; ? 0&lt;span style=&quot;color: #000000;&quot;&gt; : datas.size();
        }

    }

}&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;完成了ViewPager的初级使用，现在你可以随意自己练习一番，在两个页面中添加不同的组件，感受安卓开发的乐趣。&lt;/p&gt;

&lt;p&gt;未完待续…下一篇文章讲述使用 &lt;em&gt;RecyclerView&lt;/em&gt; 实现分类排行榜界面的编写，敬请期待！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/901197/201703/901197-20170304095215595-1669038252.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;欢迎加群大家互相交流&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304093408454-908789768.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
            <pubDate>Sat, 04 Mar 2017 00:00:00 +0800</pubDate>
        </item>
        
        <item>
            <title>【前言】实现一个Android电子书阅读APP</title>
            <link>/android/005</link>
            <guid isPermaLink="true">/android/005</guid>
            <description>&lt;p&gt;大家好，我是小方，我将在接下来的几篇文章中从零实现一个网络小说阅读器，从安卓编程最基础的部分讲起，直至成功完成我们的应用，从新建一个项目开始，不断添加新的代码，添加新的界面，循序渐进，涵盖所有我们需要的开发知识，应该可以为想要学习安卓开发的诸位提供助力。&lt;/p&gt;

&lt;p&gt;本程序使用 Android Studio 进行开发，采用 Meterial Design 设计，相信如果我能成功更新完这一系列文章，而你又成功的阅读了我的这些内容，一定可以举一反三，写出其你自己想写的应用。&lt;/p&gt;

&lt;p&gt;当然了，在安卓开发中，小方尚属小白一名，斗胆将自己刚刚学到的知识分享出来，也算是现学现卖，如有错误疏漏之处还望大家海涵。&lt;/p&gt;

&lt;h3 id=&quot;在开始的地方我们先来展示一下咱们应用的最终效果&quot;&gt;在开始的地方，我们先来展示一下咱们应用的最终效果。&lt;/h3&gt;

&lt;h2 id=&quot;图书列表&quot;&gt;图书列表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304093940313-1487048177.jpg&quot; alt=&quot;图书列表&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;排行榜&quot;&gt;排行榜&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304093948595-2039251425.jpg&quot; alt=&quot;排行榜&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;阅读界面&quot;&gt;阅读界面&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304093958532-629054657.jpg&quot; alt=&quot;阅读界面&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;阅读设置&quot;&gt;阅读设置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304094008126-2026759223.jpg&quot; alt=&quot;阅读设置&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;章节目录&quot;&gt;章节目录&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304094018954-1923163971.jpg&quot; alt=&quot;章节目录&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;图书简介&quot;&gt;图书简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304094057329-1021323825.jpg&quot; alt=&quot;图书简介&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;搜索界面&quot;&gt;搜索界面&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304094106235-1264957737.jpg&quot; alt=&quot;搜索界面&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大家看到了这么完美的最终效果心里或许会产生不小的激动呢，废话不多说了，首先从新建工程开始。&lt;/p&gt;

&lt;h2 id=&quot;下一节内容--新建项目使用viewpager创建可以来回滑动的主界面&quot;&gt;下一节内容 : 新建项目，使用ViewPager创建可以来回滑动的主界面!!!&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/xfangs/p/6498238.html&quot;&gt;创建项目&amp;amp;使用ViewPager完成基本界面设计&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎加群大家互相交流
&lt;img src=&quot;http://images2015.cnblogs.com/blog/901197/201703/901197-20170304093408454-908789768.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
            <pubDate>Fri, 03 Mar 2017 00:00:00 +0800</pubDate>
        </item>
        
        <item>
            <title>简单验证码识别</title>
            <link>/python/004</link>
            <guid isPermaLink="true">/python/004</guid>
            <description>&lt;p&gt;前情：这篇文章所提及的内容是博主上个暑假时候做的，一直没有沉下心来把自己的心得写在纸面上，所幸这个假期闲暇时候比较多，想着能写多少是多少，于是就有了此篇。&lt;/p&gt;

&lt;h1 id=&quot;验证码我也能破解&quot;&gt;验证码？我也能破解？&lt;/h1&gt;

&lt;p&gt;关于验证码的介绍就不多说了，各种各样的验证码在人们生活中时不时就会冒出来，博主身为东北大学的学生，日常接触最多的就是教务处系统的验证码了。
东大的验证码一直被学生吐槽，太难输入了，不仅区分大小写，有些时候你明明输入正确了，却提示出错，而这个时候 &lt;code class=&quot;highlighter-rouge&quot;&gt;禁止你的左键复制&lt;/code&gt; 也许该弹出来了。
（不过16-17学年度教务处更改了验证码的内容，更方便人类操作了。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o7sehhiee.bkt.clouddn.com/origin.jpg&quot; alt=&quot;原始验证码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出教务处的验证码十分有规律，每个字母数字的大小位置形状等等都是固定的，这正适合毫无基础的初学者进行验证码的识别。&lt;/p&gt;

&lt;h1 id=&quot;识别办法&quot;&gt;识别办法&lt;/h1&gt;

&lt;p&gt;模拟登陆有着复杂的步骤，在这里咱们不管其他操作，只负责根据输入的一张验证码图片返回一个答案字符串。&lt;/p&gt;

&lt;p&gt;我们知道验证码为了制作干扰，会把图片弄成五颜六色的样子，而我们首先就是要去除这些干扰，这一步就需要不断试验了，增强图片色彩，加大对比度等等都可以产生帮助。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o7sehhiee.bkt.clouddn.com/afterEnhance.jpg&quot; alt=&quot;增强&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o7sehhiee.bkt.clouddn.com/afterSelect.jpg&quot; alt=&quot;选出全黑像素&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在经过各种对图片的操作之后，终于找到了比较完美的去除干扰方案。可以看到在去除干扰之后，最优情况下，我们将得到一张十分纯净的黑白字符图片。一张图片上有四个字符，没办法一下子就把四个字符全部识别，需要把图片进行裁剪，裁剪成每张小图只有一个字符的样子，再对每张图片分别进行识别。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o7sehhiee.bkt.clouddn.com/crop1.jpg&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o7sehhiee.bkt.clouddn.com/crop2.jpg&quot; alt=&quot;+&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o7sehhiee.bkt.clouddn.com/crop3.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o7sehhiee.bkt.clouddn.com/crop4.jpg&quot; alt=&quot;=&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来就是识别文字了，我们首先把得到的小图转换成01表示的矩阵，每个矩阵代表一个字符。
比如数字六的矩阵&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;num_6=[
0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,1,1,0,0,0,0,0,0,
0,0,0,0,1,1,1,0,0,0,0,0,0,
0,0,0,1,1,1,0,0,0,0,0,0,0,
0,0,0,1,1,0,0,0,0,0,0,0,0,
0,0,1,1,0,0,0,0,0,0,0,0,0,
0,0,1,1,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,1,1,0,0,0,0,0,
0,1,1,1,1,1,1,1,1,0,0,0,0,
0,1,1,0,0,0,0,1,1,1,0,0,0,
0,1,1,0,0,0,0,0,1,1,0,0,0,
0,1,1,0,0,0,0,0,1,1,0,0,0,
0,1,1,1,0,0,0,1,1,1,0,0,0,
0,0,1,1,1,1,1,1,1,0,0,0,0,
0,0,0,1,1,1,1,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;远远望过去，眯着眼睛还是能分辨出来的。
因为东大教务处的验证码十分规整，每个数字所在的位置都是固定的，所以并不需要涉及什么机器学习的算法，只是简单的进行一下矩阵的比对就可以了，在所有的实现做好的矩阵中找到相似度最高的矩阵就可以了，在这里的比对方法多种多样，反正数据简单能正确识别出来就好。&lt;/p&gt;

&lt;p&gt;至此，咱们的验证码识别工作就结束了。&lt;/p&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;

&lt;p&gt;这次进行的验证码识别主要采用python的PIL进行图片操作，具体代码请看&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/xfangfang/studyPython/blob/master/neu/autoAAO.py&quot;&gt;xfangfang’s Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于NEU教务处模拟登陆的其他部分敬请期待。&lt;/p&gt;
</description>
            <pubDate>Sat, 21 Jan 2017 00:00:00 +0800</pubDate>
        </item>
        
        <item>
            <title>最小生成树 与 并查集</title>
            <link>/algorithm/003</link>
            <guid isPermaLink="true">/algorithm/003</guid>
            <description>&lt;p&gt;最小生成树的算法严蔚敏教材提及两种，目的都是在无向加权连通图中寻找最小生成树。两种算法主要思想均为贪心法，一个是将点加入到树中，一个是搜集边最后组合成树。&lt;/p&gt;

&lt;h1 id=&quot;prim&quot;&gt;prim&lt;/h1&gt;

&lt;p&gt;prim方法首先随机定一个起点，然后遍历其他点，找到离此顶点最近的点加入到树中，再遍历其他顶点，找到离当前两个顶点中任意一个距离最近的点，按着这种添加方法，将所有点加入到树中，就完成了prim方法。&lt;/p&gt;

&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int m,n,u,v,w;
int dis[100][100],pre[100],sl[100];
int prim(){
    for(int i=2;i&amp;lt;=n;i++){
        pre[i]=1;//pre[i]为i点所接的上一个顶点
        sl[i] = dis[1][i];//sl[i]shortLine为所有顶点至当前树的距离
    }
    sl[1] = 0;//为0代表已经选出
    pre[1]=0;
    int sum = 0;
    for(int i=2;i&amp;lt;=n;i++){
        int min = 0x3f3f3f;
        int id = 0;
        for(int j=2;j&amp;lt;=n;j++){
            if((sl[j]!=0) &amp;amp;&amp;amp; (min&amp;gt;sl[j])){
                min = sl[j];
                id = j;
            }
        }
        cout&amp;lt;&amp;lt;pre[id]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;id&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;min&amp;lt;&amp;lt;endl;
        sum+=min;
        sl[id] = 0;
        for (int j=2; j&amp;lt;=n; j++) {
            if (dis[id][j] &amp;lt; sl[j]) {
                sl[j] = dis[id][j];
                pre[j] = id;
            }
        }
    }
    return sum;
}
/*样例
5 5
1 2 1
2 3 2
3 4 3
4 5 4
1 5 3
*/
int main(int argc, const char * argv[]) {
    memset(dis,0x3f3f3f,sizeof(dis));//邻接表储存图
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);//点 边

    for(int i=1;i&amp;lt;=m;i++){
        cin&amp;gt;&amp;gt;u&amp;gt;&amp;gt;v&amp;gt;&amp;gt;w;
        dis[u][v] = dis[v][u] = w;
    }//构建图（从1至n）

    int ans = prim();
    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;prim方法需要维护两个数组，一个数组保存着边的信息被定义为 &lt;code class=&quot;highlighter-rouge&quot;&gt;pre[maxN]&lt;/code&gt; pre[i]是i节点所连的前一个顶点，当只需要求得最小生成树的权值时很明显可以把它省略掉。另一个数组 &lt;code class=&quot;highlighter-rouge&quot;&gt;sl[maxN]&lt;/code&gt; 保存着的是未加入树的点与已经形成的树的距离，每加入一个新的点，新的点的sl值设为0，与新的点相连的点的sl[i]值也需要与i到新增点的距离进行判断取最小值，最后重新设置pre值。易知，当树构建完毕时，sl数组应该全为零。&lt;/p&gt;

&lt;p&gt;#并查集&lt;/p&gt;

&lt;p&gt;在学习下一种求最小生成树的方法之前，我们先学习一下并查集的相关知识。&lt;/p&gt;

&lt;p&gt;并查集的主要目的就是把一个森林转化为几棵分别有共同根节点的树。要达到这个目的需要在每次加入新的边的时候自动连在根节点上，当然有些点在插入的时候没办法连在根节点上，所以在所有点插入完毕后再整体进行一次找根节点。&lt;/p&gt;

&lt;h3 id=&quot;代码-1&quot;&gt;代码&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
int pre[100];
int find(int x){
    int r = x;
    //找到老大
    while(pre[r] != r){
        r = pre[r];
    }
    //路径压缩--将一路上的点都直接连在老大身上
    int j = x,k;
    while(j != r){
        k = pre[j];
        pre[j] = r;
        j = k;
    }
    return r;
}
void join(int a,int b){
    int pa = find(a);
    int pb = find(b);
    if (pa != pb) {
        pre[pa] = pb;
    }
}
int main () {
    int n,m,u,v;
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for (int i=0; i&amp;lt;=n; i++) {
        pre[i] = i;
    }//初始化pre
    for (int i=0; i&amp;lt;m ; i++) {
        scanf(&quot;%d%d&quot;,&amp;amp;u,&amp;amp;v);
        join(u,v);
    }
    for (int i=1; i&amp;lt;=n; i++) {
        find(i);
    }//再进行一次整体的查找使根最少
    for (int i=1; i&amp;lt;=n; i++) {
        printf(&quot;%d &quot;,pre[i]);
    }
    return 0;
} 我最喜欢里面 ```路径压缩``` 的部分了，```路径压缩``` 是听起来十分高大上的一个词汇，但是它实现的原理十分简单，就是从当前点找到根节点，一路上遇到的所有不符合要求的数据全部连接在根节点上。 在join中，将节点少的点的根接入节点多的点的根能减小运行时间，不过要做到这一点需要额外进行其他操作，这里就不展开讨论了。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;kruskal&quot;&gt;kruskal&lt;/h1&gt;

&lt;p&gt;有了并查集的知识，再来看kruskal就眼前一亮了，kruskal算法根据边的权值大小从小权值开始加入不能组成回路的边时，就需要并查集的理念，检查即将加入的边的两个端点是否有相同的根，如果有相同的根就不能添加，换下一条边。
思路已经理清了，下面我来尝试一下。&lt;/p&gt;

&lt;h3 id=&quot;代码-2&quot;&gt;代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
struct edge{
    int u,v,w;
    bool operator &amp;lt; (const edge &amp;amp;x) const{
        return w &amp;lt; x.w;
    };
}edge;

int pre[100];
int find(int x){
    int r = x;
    //找到老大
    while(pre[r] != r){
        r = pre[r];
    }
    //路径压缩--将一路上的点都直接连在老大身上
    int j = x,k;
    while(j != r){
        k = pre[j];
        pre[j] = r;
        j = k;
    }
    return r;
}
bool join(int a,int b){
    int pa = find(a);
    int pb = find(b);
    if (pa != pb) {
        pre[pa] = pb;
    }
    else{
        return false;
    }
    return true;
}
int main () {
    int n,m,u,v,w;
    struct edge e[10000];
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for (int i=0; i&amp;lt;=n; i++) {
        pre[i] = i;
    }//初始化pre
    for (int i=0; i&amp;lt;m ; i++) {
        scanf(&quot;%d%d%d&quot;,&amp;amp;u,&amp;amp;v,&amp;amp;w);
        e[i].u = u;
        e[i].v = v;
        e[i].w = w;
    }
    sort(e, e+m);
    int sum = 0;
    for (int i=0; i&amp;lt;m; i++) {
        bool res = join(e[i].u, e[i].v);
        if(res){
            cout&amp;lt;&amp;lt;e[i].u&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;e[i].v&amp;lt;&amp;lt;endl;
            sum += e[i].w;
        }
    }
    printf(&quot;%d\n&quot;,sum);
    return 0;
} 思路十分简单，创建了一个struct来储存边，输入结束后，对边进行排序，依次添加边，如果遇到相同根的边就抛去不管，直至所有边添加成功。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由此我们也可以看出，当边数比较多时，kruskal算法可就没有prim好用了。&lt;/p&gt;
</description>
            <pubDate>Wed, 18 Jan 2017 00:00:00 +0800</pubDate>
        </item>
        
        <item>
            <title>Sort Algorithm</title>
            <link>/algorithm/002</link>
            <guid isPermaLink="true">/algorithm/002</guid>
            <description>&lt;p&gt;前情提要，本系列写于大二上学期的寒假，想要效仿前人实现一下数据结构教材上所列出的算法，从排序开始一点一点实现，，此章涉及到快速排序，希尔排序，归并排序，堆排序，基数排序。&lt;/p&gt;

&lt;h1 id=&quot;快速排序&quot;&gt;快速排序&lt;/h1&gt;

&lt;p&gt;首先我们应该懂得快速排序的原理，这样才能根据原理写出对应的算法。
快速排序使用函数递归来进行排序，在无序序列中选择一个元素X作为基准数，将数组S分为三个部分，Sa是小于X的集合，Sb是大于X的集合，再分别对Sa与Sb进行快速排序。
在这里不深究快速排序的诸多改进方法，只求实现最基本的快排。&lt;/p&gt;

&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void quickSort(int *a,int start,int end){
    int flag,turn=1;
    int l = start,r=end;
    if(end-start &amp;lt;= 0)return;
    flag = a[l];
    while(l &amp;lt; r){
        if(turn == 1){
            if(a[r] &amp;gt;= flag){
                r--;
            }
            else{
                turn = 0;
                a[l] = a[r];
	              l++;
            }
        }
        else{
            if(a[l] &amp;lt;= flag){
                l++;
            }
            else{
                turn = 1;
                a[r] = a[l];
                r--;
            }
        }
    }
    a[l] = flag;
    quickSort(a,start,l-start);//l-start是左边的长度
    quickSort(a,l+1,end - l);//end-l是右边的长度
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码是我根据原理自己写出来的，算不上简洁。在数组内元素与基准数比较大小时加入了一个标记量，判断下一次与基准数比较的元素位置，想着或许可以改进一下，不需要标记就能完成程序。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void quickSort(int *a,int start,int end){
	int l = start,r=end,flag = a[l];
	if(end-start &amp;lt;= 0) return;
	while(l &amp;lt; r){
	    while(l &amp;lt; r &amp;amp;&amp;amp; a[r] &amp;gt;= flag){
	        r--;
	    }
	    if(l &amp;lt; r){
	        a[l++] = a[r];
	    }
	    while(l &amp;lt; r &amp;amp;&amp;amp; a[l] &amp;lt;= flag){
	        l++;
	    }
	    if(l &amp;lt; r){
	        a[r--] = a[l];
	    }
	}
	a[l] = flag;
	quickSort(a,start,l-start);//l-start是左边的长度
	quickSort(a,l+1,end - l);//len - (l-start) - 1 是右边的长度
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到网上看了看别人的代码之后，发现可以用两个while来完成快排。原本最外面的while的功能被其中的两个while分担，这种思想与用栈深度优先遍历二叉树时向前进到左子树末尾的思想比较相似。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;首先快排是不稳定的，排序算法的不稳定性并不是排序过后序列还不是严格非递增或者非递减，而是在数组中有相同元素时，这个相同的元素可能会发生交换，比如序列 &lt;code class=&quot;highlighter-rouge&quot;&gt;533^&lt;/code&gt; 每次选择序列的第一个元素作为基准数，在排序后就变为了 &lt;code class=&quot;highlighter-rouge&quot;&gt;3^35&lt;/code&gt; 。
然后对快排进行分析，很明显空间复杂度为O(1),当序列为逆序时，543&lt;/p&gt;

&lt;h1 id=&quot;希尔排序&quot;&gt;希尔排序&lt;/h1&gt;

&lt;p&gt;希尔排序是直接插入排序的一种改进，将无序序列以一定的增量划分为多个子序列，再对排好一趟的序列以更小的增量划分为子序列（要求这些增量之间是互质的，不然肯定会发生重复对有序序列排序的情况）在增量已经取得较小时，进行一次直接插入排序，就完成了希尔排序的全过程。&lt;/p&gt;

&lt;h3 id=&quot;代码-1&quot;&gt;代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void shellSort(int *a,int start,int end,int i){//i为增量
    int f;
    for (int q = 0; q&amp;lt;i; q++) {
        for (int j=start+i+q; j&amp;lt;=end; j+=i) {
            if(j&amp;gt;=start+i &amp;amp;&amp;amp; a[j]&amp;lt;a[j-i]){
                f = a[j];
                int k = j;
                while (k&amp;gt;=start+i &amp;amp;&amp;amp; f&amp;lt;a[k-i]) {
                    a[k] = a[k-i];
                    k-=i;
                }
                a[k] = f;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面根据原理我自己写出的代码，实际就是插入排序的变体，因为无法确定增量的选择，所以将增量单独列出。这样在调用时只好调用多次，每次都写上不同的增量。
关于希尔排序增量序列，就不在此文的研究范围内了，会在之后的补充中逐步加入&lt;/p&gt;

&lt;h3 id=&quot;小结-1&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;希尔排序也是不稳定的，&lt;code class=&quot;highlighter-rouge&quot;&gt;533^6&lt;/code&gt; 按增量为2排序 排序后为 &lt;code class=&quot;highlighter-rouge&quot;&gt;3^356&lt;/code&gt; 这时候两个3的位置已经交换了，说明希尔排序并不稳定。&lt;/p&gt;

&lt;p&gt;未完待续…&lt;/p&gt;
</description>
            <pubDate>Tue, 17 Jan 2017 00:00:00 +0800</pubDate>
        </item>
        
        <item>
            <title>Spider NEU</title>
            <link>/python/001</link>
            <guid isPermaLink="true">/python/001</guid>
            <description>&lt;h3 id=&quot;从东北大学教务处抓包获取课程表&quot;&gt;从东北大学教务处抓包获取课程表&lt;/h3&gt;

&lt;p&gt;假期本想要尝试做一些不同的事，却一直荒废，偶然看到了幕课，顿时后悔，再借我一个假期，一定在幕课上认真学习。比自己看书效率高很多啊！&lt;/p&gt;

&lt;p&gt;于是反正无聊，用了一个晚上了解了一下python（仅限于了解），总想做点啥有意思的，想来想去还是和抓包联系上了。&lt;/p&gt;

&lt;p&gt;鉴于Wireshark我是真不怎么会用，这次抓包用的软件为Charles。&lt;/p&gt;

&lt;p&gt;Charles是Mac上比较好用的抓包软件，操作真的是十分简单，妈妈再也不用担心我不会抓包了。同时手机上的流量也是可以抓取的，将手机与电脑连在同一局域网，手动设置Wi-Fi代理，地址为电脑的内网IP，端口8888。太爱了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160229173127727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;Charles&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面就是地址了，能看出只是提交了 用户名，md5加密的密码 以及 时间。
首先先写一个md5加密的函数来&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def md5(str):
    import hashlib
    m = hashlib.md5()
    m.update(str)
    return m.hexdigest()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我不会说我都是百度来的。。。
然后是提交时间，也就是那个token,就我目前的水准来看（准小白），这个只是用来区分用户的，所以我果断的取了随机数，不过为了显得像正经的链接一点，还是把时间加在了前头。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def ran():
      import random
      return str(random.randint(1000000000000000000, 2999999999999999999))
def tim():
    import time
	day = time.strftime(&quot;%Y%m%d&quot;)
    now = time.strftime(&quot;%H%M%S&quot;)
    return  day+now
    userName = '20150000'
    passwd = md5('20150000')
    token = tim()
    url = &quot;http://202.118.31.241:8080/api/v1/login?userName=&quot;+userName+&quot;&amp;amp;passwd=&quot;+passwd+&quot;&amp;amp;token&quot;+tim()+ran()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样提交的链接就弄好了。下面是进行网络操作，引用了urllib2。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def WebView(urls):
	    import urllib2
	    request=urllib2.Request(urls)
	    web=urllib2.urlopen(request)
	    return web.read().decode('gbk').encode('utf-8')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样被我写成了函数的形式。
根据后来操作的抓包来看，系统会返回一个时间的字符串以后的请求都是根据它来进行的
	Login = WebView(url)
先把咱们“制作”出来的链接在登陆函数里运行一下，得到返回值&lt;/p&gt;

&lt;p&gt;{“success”:”0”,”errCode”:””,”errMsg”:””,”data”:{“token”:”201602291749112430008019436”,”userName”:”20150000”,”realName”:”路人甲”,”isTeacher”:”0”}}&lt;/p&gt;

&lt;p&gt;上面就是返回的Login了。
我们要获得那个token后面的数字,这个获得的东西呢是json格式的，我们进行解析就能得到token的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import json
JsonLogin = json.loads(Login)
token = JsonLogin['data']['token']
UrlKeBiao = &quot;http://202.118.31.241:8080/api/v1/courseSchedule2?token=&quot;+token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当解析过后，JsonLogin就变成了dict类型，而JsonLogin[‘data’]是dict中的dict，最终用获取的token值我们就能进行各种访问了。&lt;/p&gt;

&lt;p&gt;上面的，&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;UrlKeBiao = “http://202.118.31.241:8080/api/v1/courseSchedule2?token=”+token&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是我要的课程表地址&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;UrlKeBiao = “http://202.118.31.241:8080/api/v1/courseSchedule1?token=”+token&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;把2换成1就变成了成绩查询的地址&lt;/p&gt;

&lt;p&gt;还有什么空教室，创新学分，等等都可以查看了，这些内容都是json格式的，进行解析过后就能够流畅阅读
比如我写的解析课程表的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KeBiao = WebView(UrlKeBiao)
JsonKeBiao = json.loads(KeBiao)
k=0
r=0
while r!=6:
    print &quot;%-25.20s&quot;%(JsonKeBiao['data'][k+r]['name']),
    k+=6
    if k==42:
        k=0
        r=r+1
        print '\n'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了能正常显示汉语，还需要加上下面这四行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*
import sys
reload(sys)
sys.setdefaultencoding( &quot;utf-8&quot; )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
            <pubDate>Sat, 05 Nov 2016 00:00:00 +0800</pubDate>
        </item>
        
    </channel>
</rss>